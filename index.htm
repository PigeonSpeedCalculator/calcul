<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ELMAKKAOUY REAL FLIGHT V5</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
body{margin:0;background:#020617;color:white;font-family:Segoe UI}
#map{height:55vh}
.panel{padding:15px;background:#1e293b}
input,button{width:100%;padding:10px;margin-top:5px}
button{background:#00d4ff;color:black;font-weight:bold;border:none}
.stats{display:flex;justify-content:space-around;padding:10px;background:#0f172a}
</style>
</head>

<body>

<div id="map"></div>

<div class="stats">
<div>Ø§Ù„Ø³Ø±Ø¹Ø©: <span id="speed">0</span></div>
<div>Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: <span id="remain">0</span></div>
<div>Ø§Ù„Ø±ÙŠØ§Ø­: <span id="wind">0</span></div>
</div>

<div class="panel">
<input id="startCoords" placeholder="33.57,-7.58">
<input id="endCoords" placeholder="35.77,-5.80">
<input type="datetime-local" id="startTime">
<button onclick="initFlight()">Ø¨Ø¯Ø¡ Ø§Ù„Ø³Ø¨Ø§Ù‚</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
let map = L.map('map').setView([33.5,-7.5],6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

let startPt,endPt;
let path=[];
let pigeon,trail;
let currentIndex=0;
let BASE_SPEED=70;
let weather={windKm:15,deg:300};
let lastFrame=null;

// ------------------ Utilities ------------------

function toRad(x){return x*Math.PI/180}
function toDeg(x){return x*180/Math.PI}

function distance(a,b){
return map.distance([a.lat,a.lng],[b.lat,b.lng])/1000;
}

// ------------------ Elevation ------------------

async function getElevationBatch(points){

const body={
locations:points.map(p=>({latitude:p.lat,longitude:p.lng}))
};

const r=await fetch("https://api.open-elevation.com/api/v1/lookup",{
method:"POST",
headers:{"Content-Type":"application/json"},
body:JSON.stringify(body)
});

const d=await r.json();
return d.results.map(x=>x.elevation);
}

// ------------------ Grid Generation ------------------

function generateGrid(start,end,stepKm=10){

let minLat=Math.min(start.lat,end.lat);
let maxLat=Math.max(start.lat,end.lat);
let minLng=Math.min(start.lng,end.lng);
let maxLng=Math.max(start.lng,end.lng);

let grid=[];

for(let lat=minLat;lat<=maxLat;lat+=stepKm/111){
for(let lng=minLng;lng<=maxLng;lng+=stepKm/111){
grid.push({lat,lng});
}
}
return grid;
}

// ------------------ A* ------------------

function heuristic(a,b){
return distance(a,b);
}

function key(p){return p.lat.toFixed(4)+","+p.lng.toFixed(4)}

function findNeighbors(node,grid,stepKm=10){
return grid.filter(p=>distance(p,node)<=stepKm*1.5);
}

async function buildPath(){

let grid=generateGrid(startPt,endPt,15);

let elevations=await getElevationBatch(grid);

let costMap={};

grid.forEach((p,i)=>{
let elev=elevations[i];

if(elev<=0) costMap[key(p)]=99999; // Ø¨Ø­Ø±
else if(elev>1200) costMap[key(p)]=50; // Ø¬Ø¨Ù„
else costMap[key(p)]=1;
});

let open=[startPt];
let cameFrom={};
let gScore={};
gScore[key(startPt)]=0;

while(open.length){

open.sort((a,b)=>
(gScore[key(a)]+heuristic(a,endPt))-
(gScore[key(b)]+heuristic(b,endPt))
);

let current=open.shift();

if(distance(current,endPt)<20){
let total=[current];
while(cameFrom[key(current)]){
current=cameFrom[key(current)];
total.push(current);
}
return total.reverse();
}

let neighbors=findNeighbors(current,grid);

for(let n of neighbors){

let tentative=gScore[key(current)]
+distance(current,n)
+costMap[key(n)];

if(gScore[key(n)]===undefined
|| tentative<gScore[key(n)]){

cameFrom[key(n)]=current;
gScore[key(n)]=tentative;

if(!open.find(p=>key(p)==key(n)))
open.push(n);
}
}
}
return [startPt,endPt];
}

// ------------------ Flight ------------------

async function initFlight(){

let s=document.getElementById("startCoords").value.split(",");
let e=document.getElementById("endCoords").value.split(",");

startPt={lat:parseFloat(s[0]),lng:parseFloat(s[1])};
endPt={lat:parseFloat(e[0]),lng:parseFloat(e[1])};

path=await buildPath();

if(pigeon) map.removeLayer(pigeon);
if(trail) map.removeLayer(trail);

pigeon=L.marker(startPt,{
icon:L.divIcon({html:"ðŸ•Šï¸",className:""})
}).addTo(map);

trail=L.polyline(path,{color:"#00d4ff"}).addTo(map);

map.fitBounds(path);

currentIndex=0;
lastFrame=performance.now();

requestAnimationFrame(updateFlight);
}

function updateFlight(t){

let dt=(t-lastFrame)/1000;
lastFrame=t;

if(currentIndex>=path.length-1) return;

let a=path[currentIndex];
let b=path[currentIndex+1];

let segmentDist=distance(a,b);

let windEffect=
weather.windKm*Math.cos(
toRad(weather.deg)
);

let speed=BASE_SPEED+windEffect*0.5;
if(speed<40) speed=40;

let moveKm=(speed/3600)*dt;

if(moveKm>=segmentDist){
currentIndex++;
}else{

let ratio=moveKm/segmentDist;

let newLat=a.lat+(b.lat-a.lat)*ratio;
let newLng=a.lng+(b.lng-a.lng)*ratio;

path[currentIndex]={lat:newLat,lng:newLng};
}

pigeon.setLatLng(path[currentIndex]);

document.getElementById("speed")
.innerText=((speed*1000)/60).toFixed(1)+" m/min";

let remain=0;
for(let i=currentIndex;i<path.length-1;i++)
remain+=distance(path[i],path[i+1]);

document.getElementById("remain")
.innerText=remain.toFixed(1)+" Km";

requestAnimationFrame(updateFlight);
}

</script>
</body>
</html>

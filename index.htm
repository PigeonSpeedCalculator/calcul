/* ================== START Ù…Ø­Ø³Ù‘Ù† ================== */
async function start(){
    const s = startCoord.value.split(',');
    const lat = parseFloat(s[0]);
    const lon = parseFloat(s[1]);

    await loadWeather(lat, lon);

    const cityName = city.value || "Rabat";
    const geo = await fetch(
        `https://nominatim.openstreetmap.org/search?format=json&q=${cityName}&limit=1`
    );
    const g = await geo.json();
    if(!g[0]) return alert("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©");
    dest = [parseFloat(g[0].lat), parseFloat(g[0].lon)];

    const start = startMarker.getLatLng();
    const end = L.latLng(dest[0], dest[1]);

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ©
    const distance = map.distance(start, end);
    dist.innerText = distance.toFixed(2);

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    const dir = bearing(start.lat, start.lng, end.lat, end.lng);

    // Ø­Ø³Ø§Ø¨ Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø­
    const windAlong = windSpeed * Math.cos(rad(windDeg - dir));  // Ø¹Ù„Ù‰ Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø§Ø±
    const windCross = windSpeed * Math.sin(rad(windDeg - dir));  // Ø¹Ø±Ø¶ÙŠØ©

    // Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø£Ø±Ø¶ÙŠØ© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
    const groundSpeed = Math.sqrt(Math.pow(AIR_SPEED + windAlong, 2) + Math.pow(windCross, 2));
    speed.innerText = groundSpeed.toFixed(3);

    // Ø§Ù„Ø²Ù…Ù† Ø§Ù„ÙƒÙ„ÙŠ
    const totalTime = distance / groundSpeed;
    time.innerText = totalTime.toFixed(2);

    /* ================== ANIMATION Ù…Ø­Ø³Ù‘Ù† ================== */
    if(pigeon) map.removeLayer(pigeon);
    pigeon = L.marker(start, {icon:L.divIcon({html:'ðŸ•Šï¸',iconSize:[30,30]})}).addTo(map);

    let traveled = 0;
    let last = performance.now();

    // Ø¯Ø§Ù„Ø© Ù„Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ù…Ø³Ø§Ø± Ø§Ù„Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„Ø¹Ø¸Ù…Ù‰
    function interpolateGreatCircle(p0, p1, fraction){
        const lat1 = rad(p0.lat);
        const lon1 = rad(p0.lng);
        const lat2 = rad(p1.lat);
        const lon2 = rad(p1.lng);

        const d = 2 * Math.asin(Math.sqrt(
            Math.pow(Math.sin((lat2 - lat1)/2),2) +
            Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin((lon2 - lon1)/2),2)
        ));

        if(d === 0) return [p0.lat, p0.lng];

        const A = Math.sin((1 - fraction) * d) / Math.sin(d);
        const B = Math.sin(fraction * d) / Math.sin(d);

        const x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
        const y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
        const z = A * Math.sin(lat1) + B * Math.sin(lat2);

        const lat = Math.atan2(z, Math.sqrt(x*x + y*y));
        const lon = Math.atan2(y, x);

        return [lat * 180/Math.PI, lon * 180/Math.PI];
    }

    function animate(now){
        const dt = (now - last)/1000;
        last = now;
        traveled += groundSpeed * dt;
        let p = traveled / distance;
        if(p >= 1){pigeon.setLatLng(end); return;}
        const point = interpolateGreatCircle(start, end, p);
        pigeon.setLatLng(point);
        requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
}
